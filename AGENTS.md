Use 'bd' for task tracking

---

# Two Distinct Personas

This repository serves **two distinct AI personas** â€” understanding this distinction is critical:

| Persona | Purpose | Documentation |
|---------|---------|---------------|
| **VedaLang User Agent** | Uses VedaLang to author energy system models | `docs/vedalang-user/` and `vedalang/LLMS.md` |
| **VedaLang Design Agent** | Designs and evolves the VedaLang DSL itself | This file (`AGENTS.md`) and `docs/vedalang-design-agent/` |

## VedaLang User Agent

An AI agent that **uses VedaLang** to create `.veda.yaml` models for energy system analysis. This agent:
- Reads the VedaLang schema and examples
- Writes valid VedaLang source files
- Uses `veda_check` to validate models
- Does NOT modify the language, compiler, or schema

**User agent documentation:**
- `docs/vedalang-user/` â€” User documentation index
- `docs/vedalang-user/LLMS.md` â€” LLM guide for authoring VedaLang
- `vedalang/schema/vedalang.schema.json` â€” Language schema
- `vedalang/examples/` â€” Example models
- `rules/patterns.yaml` â€” Pattern "standard library"

## VedaLang Design Agent

An AI agent that **designs and evolves VedaLang** â€” the DSL, compiler, schemas, and tooling. This agent:
- Extends the VedaLang schema with new constructs
- Improves the compiler and emitters
- Discovers new VEDA patterns through experimentation
- Validates changes against xl2times (the oracle)

**The rest of this file is for the VedaLang Design Agent.**

---

## Package Manager

This project uses **uv** as the Python package manager.

```bash
# Sync dependencies (install/update from lockfile)
uv sync

# Add a dependency
uv add <package>

# Add a dev dependency
uv add --dev <package>

# Run a command in the venv
uv run <command>

# Run tests
uv run pytest

# Run linter
uv run ruff check .

# Run xl2times
uv run xl2times <args>
```

# VEDA DevTools - Agent Instructions

## Project Vision

Build a **safer, typed DSL** that compiles to VEDA tables â€” analogous to how TypeScript compiles to JavaScript. The new language (working name: **VedaLang**) provides:

- Type safety (units, symbols, constraints)
- Schema validation  
- Cross-reference checking
- Clear error messages

VEDA Excel tables become a **compiled artifact**, not the source. xl2times validates the compiled output.

## Architecture Overview

```
VedaLang Source (.veda.yaml)
    â”‚
    â”‚  (1) Parse + schema-validate
    â–¼
VedaLang AST  â”€â”€â–º  TableIR (in-memory)
    â”‚                  â”‚
    â”‚  (2) Type check  â”‚  (3) Deterministic Excel emission
    â–¼                  â–¼
Typed VedaLang    VEDA Excel (.xlsx)
                      â”‚
                      â”‚  (4) xl2times --diagnostics-json
                      â–¼
               TIMES DD files + Diagnostics
```

**Key insight**: VedaLang is the source; Excel is compiled output; xl2times is the validation oracle.

## Toolchain Build Order

Tools needed for an agent to **design VedaLang itself**:

| Order | Tool | Purpose |
|-------|------|---------|
| **T1** | `xl2times` + JSON outputs | Validation oracle â€” "Is this valid VEDA?" |
| **T2** | `veda_emit_excel` | TableIR â†’ Excel emitter (test VEDA patterns) |
| **T3** | `vedalang` compiler | VedaLang â†’ TableIR â†’ Excel |
| **T4** | `veda_check` | Orchestration wrapper with unified diagnostics |

## Key Principle: Agent-Designed Language

The goal is for an **AI agent to iteratively design VedaLang** using feedback tools:

1. **xl2times validation** â€” "Did I produce valid VEDA tables?"
2. **veda_check** â€” Unified lint + compile + validate feedback
3. **Decision heuristics** â€” Mapping physical concepts â†’ VEDA table patterns

We are NOT porting legacy models. This is for new model development.

## Two Separate Concerns

### 1. Language Mechanics (VedaLang)
- Syntax, types, allowed constructs
- Schema-defined (JSON Schema)
- Compiler lowers to TableIR â†’ Excel

### 2. Modeling Decisions (Heuristics)
- "Given intent X, which tags/files/fields do I use?"
- Data-driven pattern library (`rules/patterns.yaml`)
- Agent discovers these through experimentation

**These are kept separate.** VedaLang is a general-purpose VEDA authoring language; heuristics are the "standard library" of patterns.

## Repository Structure

```
veda-devtools/
â”œâ”€â”€ AGENTS.md                    # This file
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ VEDA2_NL_to_VEDA_PRD_v0_3.txt
â”œâ”€â”€ vedalang/
â”‚   â”œâ”€â”€ schema/                  # JSON Schema definitions
â”‚   â”‚   â”œâ”€â”€ vedalang.schema.json # VedaLang source schema
â”‚   â”‚   â””â”€â”€ tableir.schema.json  # TableIR schema
â”‚   â”œâ”€â”€ compiler/                # VedaLang â†’ TableIR
â”‚   â””â”€â”€ examples/                # Example VedaLang sources
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ veda_check/              # Unified validation CLI
â”‚   â””â”€â”€ veda_emit_excel/         # TableIR â†’ Excel emitter
â”œâ”€â”€ rules/
â”‚   â”œâ”€â”€ patterns.yaml            # Concept â†’ VedaLang templates
â”‚   â”œâ”€â”€ decision_tree.yaml       # Intent routing
â”‚   â””â”€â”€ constraints.yaml         # Valid tag/file combinations
â”œâ”€â”€ fixtures/
â”‚   â””â”€â”€ MiniVEDA2/               # Minimal test model
â””â”€â”€ tests/
```

## Commands

```bash
# Emit Excel from TableIR (low-level, for pattern experimentation)
veda_emit_excel tables.yaml --out model.xlsx

# Compile VedaLang to Excel
vedalang compile src/ --out model.xlsx

# Validate Excel through xl2times
xl2times model.xlsx --case base --diagnostics-json diag.json

# Full pipeline: compile + validate (preferred)
veda_check src/ --from-vedalang --case base
```

## TableIR Example

The intermediate representation between VedaLang and Excel:

```yaml
files:
  - path: base/base.xlsx
    sheets:
      - name: "Base"
        tables:
          - tag: "~FI_PROCESS"
            rows:
              - { PRC: "PP_CCGT", Sets: "ELE", TACT: "PJ", TCAP: "GW" }
          - tag: "~FI_T"
            rows:
              - { PRC: "PP_CCGT", COM_IN: "NG", COM_OUT: "ELC", EFF: 0.55 }
```

## xl2times Integration

xl2times is the **validation oracle** for compiled output. Required extensions:

- `--diagnostics-json <path>` â€” Structured error output
- `--manifest-json <path>` â€” What was parsed and how

These outputs tell the agent whether the VEDA tables it generated are valid.

## Schema-Based Design

VedaLang and TableIR are defined via **JSON Schema**:

- Enables agent introspection of valid constructs
- Tooling (validators, docs) derived from schemas
- Tests ensure schema â†” implementation alignment

Cross-reference checks and semantic constraints live in code/rules, not just schema.

## Decision Heuristics (Pattern Library)

Mapping physical/modeling concepts to VEDA patterns:

```yaml
# rules/patterns.yaml
patterns:
  add_power_plant:
    description: "Thermal generation process"
    veda_templates:
      - type: process
        technology_type: "thermal"
        default_efficiency: 0.55
        # expands into ~FI_PROCESS + ~FI_T
  
  co2_price_trajectory:
    veda_templates:
      - type: scenario_parameter
        tag: "~TFM_INS-TS"
        commodity: "CO2"
```

The agent discovers and refines these heuristics through experimentation.

## Guardrails

- **xl2times is single source of truth** â€” any discrepancy is a bug
- **Test-driven expansion** â€” no new tag/pattern without passing test
- **Schema-first changes** â€” update schema â†’ docs â†’ tests â†’ code
- **Heuristic discipline** â€” every pattern must link to a fixture example

## Notes for AI Agents

- Excel is OUTPUT, not source â€” never edit Excel directly
- Always validate through `veda_check` after generating tables
- VedaLang schema is evolving â€” propose improvements via schema changes
- Decision heuristics are learned, not hardcoded
- TableIR is your experimentation layer before committing to VedaLang syntax

---

## Agent Design Workflow

The agent iteratively designs VedaLang through a structured feedback loop:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Prototype at TableIR                                     â”‚
â”‚     - Write raw YAML tables (files/sheets/tables structure) â”‚
â”‚     - Low friction experimentation                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  2. Emit Excel                                               â”‚
â”‚     - veda_emit_excel tables.yaml --out test.xlsx           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  3. Validate with xl2times                                   â”‚
â”‚     - xl2times test.xlsx --diagnostics-json diag.json       â”‚
â”‚     - xl2times is the ORACLE - its verdict is final         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  4. Fix or Lift                                              â”‚
â”‚     - If errors: adjust TableIR, repeat from step 2         â”‚
â”‚     - If valid: lift pattern to VedaLang syntax             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Preferred workflow:** Use `veda_check` for the full pipeline:
```bash
# Validate VedaLang source end-to-end
uv run veda_check vedalang/examples/mini_plant.veda.yaml --from-vedalang

# Validate TableIR directly
uv run veda_check tables.yaml --from-tableir
```

---

## Design Phases

| Phase | Name | Focus | Status |
|-------|------|-------|--------|
| **P0** | Validate Toolchain | Tools work, feedback loop closes | âœ… DONE |
| **P1** | TableIR Experimentation | Learn valid VEDA patterns via trial | âœ… DONE |
| **P2** | Primitives Exploration | All energy system primitives | âœ… DONE |
| **P3** | MiniSystem Stress Test | Real model validation | ğŸ”„ ACTIVE |
| **P4** | Advanced Features | Time-series, scenario composition | PLANNED |

### P0: Validate Toolchain (DONE)
- âœ… `vedalang compile` works
- âœ… `veda_emit_excel` emits valid Excel
- âœ… `veda_check` orchestrates pipeline
- âœ… xl2times emits structured diagnostics (not crashes)
- âœ… `mini_plant.veda.yaml` passes VedaLang compilation

### P1: TableIR Experimentation (DONE)
- âœ… DC1-DC5 design challenges complete
- âœ… Golden fixture regression tests
- âœ… Schema evolution policy
- âœ… Failure tracking infrastructure

### P2: Primitives Exploration (DONE)
All 10 energy system primitives explored and schema extensions implemented:
- âœ… Thermal/renewable generation, CHP, storage, transmission (patterns)
- âœ… Demand projections, costs, bounds, timeslices, trade, user constraints (schema)

### P3: MiniSystem Stress Test (ACTIVE)
Epic: `vedalang-93s`

Open tasks:
- `vedalang-5dw` â€” Design MiniSystem model specification
- `vedalang-scv` â€” Implement MiniSystem in VedaLang
- `vedalang-4t8` â€” Wire as golden CI test

### P4: Advanced Features (PLANNED)
- `vedalang-6qs` â€” Time-varying process attributes
- `vedalang-9xy` â€” Scenario composition
- `vedalang-a9m` â€” Units and dimension checking

---

## Design Challenges

Incremental challenges to validate VedaLang expressiveness:

| ID | Challenge | Concepts Tested |
|----|-----------|-----------------|
| **DC1** | Reproduce mini thermal plant via patterns | Basic process, commodity, topology |
| **DC2** | Add renewable plant sharing output commodity | Multiple processes, shared commodities |
| **DC3** | Introduce emission commodity and emission factor | Emission tracking, ENV_ACT |
| **DC4** | Add CO2 price trajectory scenario | TFM tags, time-varying parameters |
| **DC5** | Two-region model extension | Multi-region, trade, IRE processes |

### Challenge Protocol

For each challenge:
1. **Describe intent** in natural language
2. **Prototype** in TableIR
3. **Validate** with xl2times
4. **Capture pattern** if successful
5. **Lift to VedaLang** syntax if pattern is general

---

## Failure Handling

Every failure is a learning opportunity. Failures are categorized and preserved.

### Failure Types

| Type | Description | Action |
|------|-------------|--------|
| **A** | Wrong VEDA structure | Fix TableIR, re-validate |
| **B** | VedaLang can't express valid pattern | Extend VedaLang schema |
| **C** | Compiler bug | Fix compiler, add regression test |

### Failure Preservation

```bash
# Create failure test case
mkdir -p tests/failures/
cp failing_input.yaml tests/failures/type_a_missing_column.yaml
# Add corresponding test that expects the failure
```

### Failure-to-Test Workflow

1. Reproduce failure with minimal input
2. Capture in `tests/failures/` or inline in test file
3. Write test that:
   - For Type A: expects xl2times error diagnostic
   - For Type B: documents the gap (skip with reason)
   - For Type C: expects correct behavior after fix

---

## Guardrails

### Golden Fixtures

- `fixtures/MiniVEDA2/` is the regression reference
- Any change that breaks fixture validation is a bug
- Run `uv run pytest tests/` after any changes

### Schema Evolution Policy

See [docs/vedalang-design-agent/schema_evolution.md](docs/vedalang-design-agent/schema_evolution.md) for the full policy.

**Quick rules:**
- **Add** optional fields freely
- **Never remove** required fields without deprecation
- **Never narrow** enum values (only add new ones)
- Run `uv run pytest tests/test_schema_compatibility.py` before schema changes

### Pattern Versioning

- Patterns in `rules/patterns.yaml` are versioned
- New versions rather than mutation: `add_power_plant_v2`
- Old versions remain for backward compatibility

### Validation Gates

```bash
# Run before committing
uv run pytest tests/
uv run ruff check .

# Full validation
uv run veda_check vedalang/examples/mini_plant.veda.yaml --from-vedalang
```

---

## Diagnostic Codes Reference

xl2times emits structured diagnostics. See [docs/vedalang-design-agent/baseline_diagnostics.md](docs/vedalang-design-agent/baseline_diagnostics.md) for details.

### Quick Reference

| Code | Severity | Description |
|------|----------|-------------|
| `MISSING_REQUIRED_TABLE` | error | Required VEDA table not present |
| `MISSING_REQUIRED_COLUMN` | error | Required column missing from table |
| `INVALID_SCALAR_TABLE` | error | Table expected one value, got wrong shape |
| `MISSING_TIMESLICES` | warning | No timeslice definitions found |
| `INTERNAL_ERROR` | error | Uncaught exception during processing |

### Reading Diagnostics

```bash
# Generate diagnostics
uv run xl2times model.xlsx --diagnostics-json diag.json

# Key fields in output
cat diag.json | jq '.diagnostics[] | {code, severity, message}'
```

---

## Keeping STATUS.md Updated

The living status document is [`docs/project-status/STATUS.md`](docs/project-status/STATUS.md). Keep it in sync with `bd` issues.

### When to Update STATUS.md

- **At session start** â€” Run sync script to check current state
- **When closing issues** â€” Move from "Open Tasks" to completed section
- **When creating issues** â€” Add to appropriate section
- **On phase transitions** â€” Update "Current Phase" section

### Quick Sync Commands

```bash
# Generate status summary from bd issues
uv run python tools/sync_status.py

# Show current open issues
bd list --all | grep " open "

# Count closed issues  
bd list --all | grep " closed " | wc -l
```

### What to Update

1. **Open Tasks table** â€” Must match `bd list --all | grep " open "`
2. **Closed count** â€” Update "X issues closed" number
3. **Current Phase** â€” Update when epic completes
4. **Capabilities table** â€” Add new features as implemented

---

## Landing the Plane (Session Completion)

**When ending a work session**, you MUST complete ALL steps below. Work is NOT complete until `git push` succeeds.

**MANDATORY WORKFLOW:**

1. **File issues for remaining work** - Create issues for anything that needs follow-up
2. **Run quality gates** (if code changed) - Tests, linters, builds
3. **Update issue status** - Close finished work, update in-progress items
4. **Update STATUS.md** - Sync with current bd issue state
5. **PUSH TO REMOTE** - This is MANDATORY:
   ```bash
   git pull --rebase
   bd sync
   git push
   git status  # MUST show "up to date with origin"
   ```
6. **Clean up** - Clear stashes, prune remote branches
7. **Verify** - All changes committed AND pushed
8. **Hand off** - Provide context for next session

**CRITICAL RULES:**
- Work is NOT complete until `git push` succeeds
- NEVER stop before pushing - that leaves work stranded locally
- NEVER say "ready to push when you are" - YOU must push
- If push fails, resolve and retry until it succeeds
